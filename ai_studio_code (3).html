<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- é€‚é…æ‰‹æœºå±å¹• -->
    <title>Jingçš„é­”æ³•åœ£è¯æ ‘</title>
    <style>
        /* 1. åŸºç¡€æ ·å¼ï¼šé»‘è‰²èƒŒæ™¯ï¼Œæ— æ»šåŠ¨æ¡ */
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        
        /* 2. åŠ è½½æç¤ºå­—æ · */
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            text-align: center; font-size: 18px; color: #ffd700;
            pointer-events: none; z-index: 999;
        }

        /* 3. ç®€å•çš„æŒ‰é’®é¢æ¿ */
        #ui {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 8px;
        }
        button {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px 15px; margin: 5px; cursor: pointer; border-radius: 4px;
        }
        button:active { background: #00ff88; color: black; }

        /* 4. éšè—åŸå§‹æ‘„åƒå¤´ç”»é¢ï¼Œåªç•™ç‰¹æ•ˆ */
        #webcam { display: none; }
    </style>

    <!-- 5. å¼•å…¥ 3D å¼•æ“ (Three.js) å’Œ AI (MediaPipe) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- ç•Œé¢å…ƒç´  -->
    <div id="loading">ğŸ„ æ­£åœ¨ç§æ¤åœ£è¯æ ‘...<br><span style="font-size:12px;color:#aaa">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦ 20 ç§’</span></div>
    
    <div id="ui">
        <button onclick="window.location.reload()">ğŸ”„ åˆ·æ–°é‡ç½®</button>
    </div>

    <!-- 3D ç”»å¸ƒå®¹å™¨ -->
    <div id="canvas-container"></div>
    <!-- æ‘„åƒå¤´æº -->
    <video id="webcam" autoplay playsinline></video>

    <!-- æ ¸å¿ƒé€»è¾‘è„šæœ¬ -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // å˜é‡å‡†å¤‡
        let scene, camera, renderer, particles;
        const particleCount = 4000; // ç²’å­æ•°é‡
        const positions = new Float32Array(particleCount * 3); // ç²’å­ä½ç½®
        const originalPositions = new Float32Array(particleCount * 3); // è®°ä½æ ‘çš„å½¢çŠ¶
        const colors = new Float32Array(particleCount * 3); // ç²’å­é¢œè‰²
        let targetSpread = 0; // 0=æ ‘å½¢æ€, 1=ç‚¸å¼€å½¢æ€
        let currentSpread = 0;

        // --- ç¬¬ä¸€æ­¥ï¼šæ­å»º 3D èˆå° ---
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // é»‘è‰²è¿·é›¾

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 35); // ç›¸æœºä½ç½®

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // å…è®¸é¼ æ ‡æ—‹è½¬
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // çª—å£å¤§å°æ”¹å˜æ—¶è‡ªåŠ¨è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- ç¬¬äºŒæ­¥ï¼šç§ä¸‹åœ£è¯æ ‘ (ç²’å­ç”Ÿæˆ) ---
        function createTree() {
            const geometry = new THREE.BufferGeometry();

            for (let i = 0; i < particleCount; i++) {
                // æ ‘çš„å½¢çŠ¶ç®—æ³• (åœ†é”¥ä½“)
                const h = 35; // æ ‘é«˜
                const y = Math.random() * h - h / 2; // é«˜åº¦èŒƒå›´
                const radius = (1 - (y + h / 2) / h) * 12; // ä¸‹é¢å®½ä¸Šé¢çª„
                const angle = Math.random() * Math.PI * 2; // 360åº¦æ—‹è½¬
                const r = radius * Math.sqrt(Math.random()); // å†…éƒ¨å¡«å……

                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);

                // è®°å½•ä½ç½®
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                // é¢œè‰²ï¼šæ··å…¥é‡‘è‰²å’Œç»¿è‰²
                const color = Math.random() > 0.8 ? new THREE.Color(0xffd700) : new THREE.Color(0x00ff88);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // æè´¨ï¼šå‘å…‰çš„å°ç‚¹
            const material = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- ç¬¬ä¸‰æ­¥ï¼šåŠ¨ç”»å¾ªç¯ (è®©å®ƒåŠ¨èµ·æ¥) ---
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
            currentSpread += (targetSpread - currentSpread) * 0.1;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const ox = originalPositions[i3];
                const oy = originalPositions[i3 + 1];
                const oz = originalPositions[i3 + 2];

                // çˆ†ç‚¸é€»è¾‘ï¼šä½ç½® = åŸå§‹ä½ç½® * (1 + æ‰©æ•£ç³»æ•°)
                const explosion = 1 + currentSpread * 2; 

                positions[i3] = ox * explosion;
                positions[i3 + 1] = oy * explosion;
                positions[i3 + 2] = oz * explosion;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- ç¬¬å››æ­¥ï¼šå¯åŠ¨ AI æ‘„åƒå¤´ (æœ€éš¾çš„ä¸€æ­¥ï¼ŒåŠ äº†ä¿é™©) ---
        async function startAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const video = document.getElementById('webcam');
                // è¯·æ±‚æ‘„åƒå¤´
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;

                document.getElementById('loading').innerHTML = "âœ… ç³»ç»Ÿå¯åŠ¨æˆåŠŸï¼<br>è¯·å¯¹ç€æ‘„åƒå¤´<br>å¼ å¼€æ‰‹æŒ = çˆ†ç‚¸ | æ¡æ‹³ = è¿˜åŸ";
                
                // å¼€å§‹æŒç»­æ£€æµ‹
                let lastTime = -1;
                function predict() {
                    if (video.currentTime !== lastTime) {
                        lastTime = video.currentTime;
                        const result = handLandmarker.detectForVideo(video, performance.now());
                        
                        if (result.landmarks.length > 0) {
                            // æ£€æµ‹åˆ°æ‰‹äº†ï¼
                            const hand = result.landmarks[0];
                            // ç®€å•ç®—æ³•ï¼šé£ŸæŒ‡æŒ‡å°– (8) åˆ° æ‰‹è…• (0) çš„è·ç¦»
                            const tip = hand[8];
                            const wrist = hand[0];
                            const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));

                            // è·ç¦»å¤§äº 0.3 ç®—å¼ å¼€ï¼Œå¦åˆ™ç®—æ¡æ‹³
                            targetSpread = dist > 0.3 ? 1 : 0;
                        }
                    }
                    requestAnimationFrame(predict);
                }
                predict();

            } catch (error) {
                console.error(error);
                document.getElementById('loading').innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æƒé™ï¼Œæˆ–æ¢ä¸ªæµè§ˆå™¨(æ¨èChrome)";
            }
        }

        // --- å¯åŠ¨æ‰€æœ‰ç¨‹åº ---
        initScene();
        createTree();
        animate();
        startAI(); // å¯åŠ¨ AI
    </script>
</body>
</html>
